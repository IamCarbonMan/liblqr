
LiquidRescale library
=====================

Table of contents
-----------------
  * Introduction
    + Seam carving in brief
    + Library features (*)
  * Installation
    + Requirements
    + Normal setup
  * Using the library
  * The library API
    + Overview
    + Basic methods (*)
    + Generating the multi-size image
    + Liquid rescaling
    + Reading the multi-size image (!)
    + Adding a bias (*)
    + Tuning
    + Dealing with the visibility map (the seams) (!)
    + Attaching extra images (!)
    + Progress indicators (!)
  * Additional notes
  * References
  * Copyright


+ Introduction
--------------

The LiquidRescale (lqr) library provides a C/C++ API for
performing non-uniform resizing of images by the seam-carving
technique.

++ Seam carving in brief

Basically, an algorithm tries to find out which parts
of the image are important, and which are not; then, the image
is resized through the elimination or insertion of continuous
paths, called `seams'. The seams connect the top of the image
with the bottom when rescaling horizontally, or they connect
the left side with the right side when rescaling vertically.
In the seam carving process, seams are removed in sequence.
The seam insertion process mirrors the seam carving process,
introducing interpolated seams in regions where they would have
been carved.
See the sections "Additional notes" and "References" for more
information.

++ Library features

The library functions take images in plain array format as input
and convert them to a multi-size representation.

  * The automatic feature detection algorithm can be tuned
    by selecting among different energy gradient functions
  * Areas in the image can be marked for preservation or
    discard
  * Once the image has been fully processed, the scaling can
    be done in real-time. In fact, the information can be saved
    and read out later without any further processing.
    (this is only possible if resizing along a single direction)
  * The resizing is done with a single function which
    automatically performs all the necessary operations; it
    can also work in successive steps without wasting
    computational time
  * Possibility to tune the carving operation by letting the
    seams be less connected, or more rigid, or both 
  * Can export and import the visibility map (the seams)
  * Other images can be attached and undergo the same carving
    process as the parent image 
  * Reports progress through a customizable interface
  * All memory calls are protected and can be cleanly handled



+ Installation
--------------

++ Requirements

The lqr library requires the glib-2.0 libraries

++ Normal setup

The build package uses autotools and libtool, so the installation
commands on Unix systems are simply

./configure --prefix=/usr && make && sudo make install

The last step requires administrative privileges.
(If the dynamic linker path includes /usr/local/lib, the --prefix
option is not needed.)

See the INSTALL file for a full description.



+ Using the library
------------------------

In order to use the library functions and structures from
a C or C++ program, you have to add this include line in 
your program:

#include <lqr/lqr.h>

At compile time, you can take advantage of pkg-config to set
the proper flags. In the `example' directory you can find
an example file, "liquidrescale.cpp", and a simple Makefile,
which demonstrate how to use the basic library functions
and to compile it. See the README file in that directory
for more information.



+ The library API
-----------------

++ Overview

Multi-size images are stored simply as plain images with the addition
of a visibility map. Each pixel in the image has its own visibility level.
We decide whether to display a pixel or not simply by comparing each pixel's
visibility with a given global visibility level. In this way, we can read
out images of different sizes, simply by setting properly a global visibility
level. This is at the base of the possibility of real-time scaling.

Note that this technique only works if the resizing happens on a single
direction, in which case we can go back and forth effortlessly just
as described above. If we want to resize on the other direction,
the visibility map has to be computed afresh, and the previous visibility
map has to be wasted, because the two maps are not consistent one with each
other.
This also implies that the resizing order affects the final result.

When the multi-size image is created in a LqrCarver object, the visibility
of each pixel is uninitialized. At this point, one could either import a
previously computed visibility map, or initialize the LqrCarver so that
it performs the needed computations when asked.

In either case, there's a single method to call, specifiying the new
desired size, and the visibility map will computed as necessary.

 
++ Basic methods

The main lqr library class is LqrCarver, which is used to
generate and store the multi-size image representation.
Its basic public methods are:

  +++ constructor and destructor
    LqrCarver * lqr_carver_new (guchar * buffer, gint width, gint height, gint bpp)
    void lqr_carver_destroy (LqrCarver * r)

  +++ initialization
    gboolean lqr_carver_init (LqrCarver *r, gint delta_x, gfloat rigidity)

  +++ image manipulations
    gboolean lqr_carver_resize (LqrCarver * r, gint w1, gint h1)
    gboolean lqr_carver_flatten (LqrCarver * r)

  ++ readout
    void lqr_carver_read_reset (LqrCarver * r)
    gboolean lqr_carver_read_next (LqrCarver * r)
    gint lqr_carver_read_x (LqrCarver * r)
    gint lqr_carver_read_y (LqrCarver * r)
    guchar lqr_carver_read_c (LqrCarver * r, gint col)

  +++ get values
    gint lqr_carver_get_width (LqrCarver * r)
    gint lqr_carver_get_height (LqrCarver * r)

The other classes are optional. The class LqrProgress is used to
customize progress report from the resizing engine, which by
default is turned off. The classes LqrSeamsBuffer and
LqrSeamsBufferList are used to store and access the computed seam
maps.


++ Generating the multi-size image

The LqrCarver objects are initialized from a plain buffer of unsigned
chars representing an image, in which each colour channel takes a value
between 0 and 255, through this function:

LqrCarver * lqr_carver_new (guchar * buffer, int width, int height, int bpp)

  buffer: a plain array of unsigned characters representing an image.
          The array must be ordered by row, then by column, then by
          colour channel, see below. The total size of the array
          has to be equal to width * hieght * bpp.
  width:  the initial width of the image
  height: the initial heigth of the image
  bpp:    the array bytes-per-pixel, i.e. the number of colour channels

The return value is a pointer to a newly created object, or NULL in
case of failure.

For the buffer to be interpreted correctly, the k-th colour of
the pixel at row y and column x has to be located at:

buffer[(y * width + x) * bpp + k]

(this assumes that x, y and k all start from 0 and reach widht-1, height-1
and bpp-1, respectively)

The newly created LqrCarver consists only of the image buffer plus
an uninitialized visibility map. If one had a previously computed
visibility map, it could be imported into the LqrCarver and that would be
enough.

If the visibility map has to be computed, the LqrCarver needs to be
initialized through this function:

gboolean lqr_carver_init (LqrCarver *carver, gint delta_x, gfloat rigidity)

  carver:   the LqrCarver to initialize
  delta_x:  the maximum allowed transversal step of the seams
            (0 means straight seams, default is 1)
  rigidity: this parameter can be used to introduce a bias for non-stright
            seams (default is 0)

The return value is TRUE on success, FALSE in case of memory allocation
failures.


++ Liquid rescaling

Once initialized, the image can be resized through this function:

gboolean lqr_carver_resize (LqrCarver * r, gint w1, gint h1)

  carver: the carver to resize
  w1:     the desired new width
  h1:     the desired new height

The return value is TRUE on success, FALSE in case of memory allocation
failures.

This function decides automatically whether it can use the already computed
visibility map, it has to update it or waste it completely and start
afresh. This last event occurs when the map was computed for horizontal
resizing and a vertical resize has been requested, or vice versa.

The function also takes advantage of the fact that the enlargment process
mirrors the shrink process. For example, if the original size of the image
is (w0,h0) and lqr_carver_resize is invoked with (w0 - 100, h0) as an
argument, then subsequent calls to the function will allow on-the-fly
resizing in the whole range from (w0 - 100, h0) to (w0 + 100, h0).

Note that it is an error to ask for a size greater than twice the initial
size in one step. See also the section "Additional notes" below.

In order to resize in more than one step, the image can be flattened in
its current state, thrugh this function:

gboolean lqr_carver_flatten (LqrCarver * carver)

The return value is FALSE in case of insufficient memory, as before.

This function destroys the current visibility map and reinitializes
the multi-size image from its current state.

Note that every time that the image is flattened (including when changing
the resize direction) the original image is lost.


++ Reading the multi-size image


++ Adding a bias

The automatic feature detection can be driven manually by
adding a bias to the pixels of the image.

For example, it is possible to protect regions of the image by
adding a positive bias to the corresponding pixels. This will
make the seams more unlikely to cross those regions, thus
avoiding distortion (but increasing distortion of the other
regions).

It is also possible to make the seams more likely to cross some
regions by adding a negative bias to them. In this case, reducing
the size of the image will tend to erase those regions, while
(possibly) keeping the rest of the image in a consistent state. 

See also the section "Additional notes" below for situations
where the behaviour iof biased regions can be counter-intuitive.

The bias can be set directly, after initialization and before
resizing, by accessing the bias array inside the LqrStructure.
This is a plain array of doubles, of size (widht * height),
ordered by rows.

For example, if we have an initialized pointer to a LqrCarver
caller carver, and we want to set to 10.5 the bias of the pixel
at coordinates (x,y), we use:

carver->bias[(y * carver->w) + x] = 10.0;

(here x and y start from 0)

[ hey, don't look me like this: -.- ]


++ Tuning

The behaviour can be tuned through some additional functions.

The automatic feature detection relies on the computation
of the gradient in each pixel of the image. The precise
function to use can be set through:

void lqr_carver_set_gradient_function (LqrCarver * carver, LqrGradFuncType gf_ind);

The possible values for gf_ind are:
 
  LQR_GF_XABS   : transversal absolute value (default)
  LQR_GF_NORM   : gradient norm
  LQR_GF_SUMABS : sum of absulte values
  LQR_GF_NULL   : null

The null value can be used to override completely the automatic
feature detection (see the "Adding a bias" section above).

When lqr_carver_resize is asked to resize along both directions
in a single step, it has to choose which direction to resize first.
The resize order can be changed through this function:

void lqr_carver_set_resize_order (LqrCarver *r, LqrResizeOrder resize_order);

The possible values for resize_order are:
  LQR_RES_ORDER_HOR  : resize horizonally first (default) 
  LQR_RES_ORDER_VERT : resize vertically first


++ Dealing with the visibility map (the seams)


++ Attaching extra images


++ Progress indicators


+ Additional notes
------------------

* double size note
* enlargment notes



+ References
------------

The library implements the algorithm described in the paper
"Seam Carving for Content-Aware Image Resizing"
by Shai Avidan and Ariel Shamir, which can be found at
http://www.faculty.idc.ac.il/arik/imret.pdf



+ Copyright
-----------

Copyright (C) 2007 Carlo Baldassi <carlobaldassi@yahoo.it>

