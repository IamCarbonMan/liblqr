
The LiquidRescale library Manual
================================

Table of contents
-----------------

  * About this document
  * Overview
  * Basic methods
  * Signal handling
  * Generating the multi-size image
    + Carver object creation
    + Carver activation
  * Liquid rescaling
    + The resizing method 
    + Flattening
  * Reading the multi-size image
    + Pixel by pixel
    + One line at a time
  * Adding a bias
    + Foreword
    + Using an array of floating-point values
    + Using another image
    + Operating on a specific area
  * Tuning
    + Choosing a gradint function
    + Choosing the resize order
  * Dealing with the visibility maps (the seams)
    + Activating the visibility map storage
    + Accessing the dumped visibility maps
    + The visibility map objects
    + Importing a visibility map in a carver
    + Saving and loading visibility maps to/from files
  * Attaching extra images
    + Attaching a carver
    + Accessing attached carvers
  * Progress indicators
  * Full list of library methods
  * Copyright


+ About this document
---------------------

This manual describes in detail the LiquidRescale library API, starting
from a brief overview on the internal image representation, a minimal
list of basic methods, the description of the signalling system for error
handling, and the full explanation of all the library public methods.

In the `examples' directory, you will find a minimal example program,
which only uses basic methods, and a full-featured demo program,
which uses almost all of the methods described in this document.
Both programs are fully commented, see also the README file in the
`examples' directory.

Refer to the README file for information about intalling and compiling,
and some additional notes.




+ Overview
----------

Multi-size images are stored simply as plain images with the addition
of a visibility map. Each pixel in the image has its own visibility level.
We decide whether to display a pixel or not simply by comparing each pixel's
visibility with a given global visibility level. In this way, we can read
out images of different sizes, simply by setting properly a global visibility
level. This is at the base of the possibility of real-time scaling.

Note that this technique only works if the resizing happens on a single
direction, in which case we can go back and forth effortlessly just
as described above. If we want to resize on the other direction,
the visibility map has to be computed afresh, and the previous visibility
map has to be wasted, because the two maps are not consistent one with each
other.
This also implies that the resizing order affects the final result.

The multi-size representation is generated and stored in objects of type
LqrCarver. When one of such objects is created from an input image, the
visibility of each pixel is uninitialized. At this point, one could either
import a previously computed visibility map, or activate the LqrCarver so
that it performs the required computations when asked.

In either case, there's a single method to call, specifiying the new
desired size; all the rest will automatically be computed as necessary.

 

+ Basic methods
---------------

The main lqr library class is LqrCarver, which is used to
generate and store the multi-size image representation.
Its basic public methods are:

  ++ constructor and destructor
    LqrCarver * lqr_carver_new (guchar *buffer, gint width, gint height, gint bpp)
    void lqr_carver_destroy (LqrCarver *r)

  ++ initialization
    LqrRetVal lqr_carver_init (LqrCarver *r, gint delta_x, gfloat rigidity)

  ++ image manipulations
    LqrRetVal lqr_carver_resize (LqrCarver *r, gint w1, gint h1)
    LqrRetVal lqr_carver_flatten (LqrCarver *r)

  ++ readout
    gboolean lqr_carver_scan (LqrCarver *r, gint *x, gint *y, guchar **rgb)
    gboolean lqr_carver_scan_by_row (LqrCarver *r)
    gboolean lqr_carver_scan_line (LqrCarver *r, gint *n, guchar **rgb)

  ++ get values
    gint lqr_carver_get_width (LqrCarver *r)
    gint lqr_carver_get_height (LqrCarver *r)
    gint lqr_carver_get_bpp (LqrCarver *r)

The fastest way to see how they work is having a look at the code
of examples/liquidrescale-basic.cpp, which is a very simple and fully
commented demostrative program.

The return value of many functions is of type LqrRetVal. This is just an
enum type which can be used for signal handling, see below.

The other classes are optional: the class LqrVMap is used to hold the
carving information (and the class LqrVMapList is used to retrieve it
from the LqrCarver ojects); the class LqrProgress is used to customize
progress report from the resizing engine (by default is turned off).

A complete list of the library public method can be found at the
end of this document


+ Signal handling
-----------------

Many library functions return a value of type LqrRetVal. This is an enum
type which can hold the values:
  LQR_OK      : everything ok
  LQR_ERROR   : generic fatal error
  LQR_NOMEM   : not enough memory

At top level, the user should handle this values explicitely, because
the library doesn't do anything else than stopping and returning an
error signal in case of errors. An easy way is setting up some macros
and wrap each function call with those, as shown in the examples.

Below top level, the library provides some convenient macros which can be used
to wrap function calls, in order to handle or genertate these signals:
  CATCH (expr)     : if expr != LQR_OK return expr
  CATCH_F (expr)   : if expr == FALSE return LQR_ERROR
  CATCH_MEM (expr) : if expr == NULL return LQR_NOMEM



+ Generating the multi-size image
----------------------------------

++ Carver object creation

The LqrCarver objects are initialized from a plain buffer of unsigned
chars representing an image, in which each colour channel takes a value
between 0 and 255, through this function:

LqrCarver * lqr_carver_new (guchar * buffer, int width, int height, int bpp)

  buffer: a plain array of unsigned characters representing an image.
          The array must be ordered by row, then by column, then by
          colour channel, see below. The total size of the array
          has to be equal to width * hieght * bpp.
  width:  the initial width of the image
  height: the initial heigth of the image
  bpp:    the array bytes-per-pixel, i.e. the number of colour channels

The return value is a pointer to a newly created object, or NULL in
case of insufficient memory.

For the buffer to be interpreted correctly, the k-th colour of
the pixel at row y and column x has to be found at:

buffer[(y * width + x) * bpp + k]

(this assumes that x, y and k all start from 0 and reach widht-1, height-1
and bpp-1, respectively)

Note that the buffer will be incorporated into the LqrCarver object and
must not be accessed directly any more.

++ Carver activation

The newly created LqrCarver consists only of the image buffer plus
an uninitialized visibility map. If one had a previously computed
visibility map, it could be imported into the LqrCarver and that would be
enough (see below).

If the visibility map has to be computed, the LqrCarver needs to be
initialized through this function:

LqrRetVal lqr_carver_init (LqrCarver *carver, gint delta_x, gfloat rigidity)

  carver:   the LqrCarver to initialize
  delta_x:  the maximum allowed transversal step of the seams
            (0 means straight seams, default is 1)
  rigidity: this parameter can be used to introduce a bias for non-stright
            seams (default is 0)

Note that it is currently an error to initalize a carver object
if a visibility map has been imported already.


+ Liquid rescaling
------------------

++ The resizing method 

Once initialized, or if a visibility map has been loaded, the image can be
resized through this function:

LqrRetVal lqr_carver_resize (LqrCarver * r, gint w1, gint h1)

  carver: the carver to resize
  w1:     the desired new width
  h1:     the desired new height

This function decides automatically whether it can use the already computed
visibility map, it has to update it or waste it completely and start
afresh. This last event occurs when the map was computed for horizontal
resizing and a vertical resize has been requested, or vice versa.
Note that only initialized carvers can update or change the visibility
map; if this is not the case, an error is returned.

The function also takes advantage of the fact that the enlargment process
mirrors the shrink process. For example, if the original size of the image
is (w0,h0) and lqr_carver_resize is invoked with (w0 - 100, h0) as an
argument, then subsequent calls to the function will allow on-the-fly
resizing in the whole range from (w0 - 100, h0) to (w0 + 100, h0).

Note that it is an error to ask for a size greater than twice the initial
size in one step. See also the section "Additional notes" in the README file.

++ Flattening

In order to resize in more than one step, the image can be flattened in
its current state, thrugh this function:

gboolean lqr_carver_flatten (LqrCarver * carver)

The return value is FALSE in case of insufficient memory, as before.

This function destroys the current visibility map and reinitializes
the multi-size image from its current state.

Note that every time that the image is flattened (including when changing
the resize direction) the original image is lost.



+ Reading the multi-size image
------------------------------

++ Pixel by pixel

Once you have rescaled the image, you can read out the result through
this function:

gboolean lqr_carver_scan (LqrCarver *carver, gint *x, gint *y, guchar **rgb)

  carver: the carver to read
  x:      the address of a variable to hold the x coordinate
  y:      the address of a variable to hold the y coordinate
  rgb:    the address of a guchar array which will hold the pixel information

The return value is FALSE when the end of the image is reached,
TRUE otherwise.

Each time this function is invoked, it will store
the coordinates and rgb information in the output pointers
and move to the next pixel. If it reaches the end, it
resets the reader and returns FALSE.

Here is a sample code usage:

 >     gint x, y;
 >     guchar *rgb;
 >     
 >     while (lqr_carver_scan (carver, &x, &y, &rgb)
 >       {
 >         my_plot (x, y, rgb[0], rgb[1], rgb[2]);
 >       }

In this example, it is assumed that the image has 3 colour
channels, and that there exist some function my_plot which
writes out the pixels somewhere.
Note that the rgb array is internal to the carver object, 
so it doesn't need initialization (but don't use pointers
to it or its elements, always copy the contents as in the
example).

++ One line at a time

The image can also be read one line at a time, but it is
not possible to freely decide if it is to be read by row or
by column. Instead, this has to be queried by calling this
function: 

gboolean lqr_carver_scan_by_row(LqrCarver *carver)

which returns TRUE if the image is read by row, and FALSE
if it is read by column.

Then, the image can be read through this function:

gboolean lqr_carver_scan_line (LqrCarver *carver, gint *n, guchar **rgb)

which works exactly the same way as lqr_carver_scan, but
only one coordinate is stored (either the row or the column number),
and the rgb array will contain a whole line.

Here is a sample code usage:

 >     gint n;
 >     guchar *rgb;
 >     gboolean by_row;
 > 
 >     by_row = lqr_carver_scan_by_row (carver);
 >     
 >     while (lqr_carver_scan_line (carver, &n, &rgb)
 >       {
 >         by_row ? my_plot_row (n, rgb) : my_plot_col (n, rgb);
 >       }

where, as before, it is assumed that the my_plot_row/col functions
have been previously defined and "know what to do".

++ Resetting

Normally, it is not needed to reset the image scan. However, if the
scan has been stopped at same intermediate step for some reason, the
following function can be used to restart from the beginning:

void lqr_carver_scan_reset (LqrCarver *r)



+ Adding a bias
---------------

++ Foreword

The automatic feature detection can be driven manually by
adding a bias to the pixels of the image.

For example, it is possible to protect regions of the image by
adding a positive bias to the corresponding pixels. This will
make the seams more unlikely to cross those regions, thus
avoiding distortion (but increasing distortion of the other
regions).

It is also possible to make the seams more likely to cross some
regions by adding a negative bias to them. In this case, reducing
the size of the image will tend to erase those regions, while
(possibly) keeping the rest of the image in a consistent state. 

NOTE #1 : The bias has to be added always AFTER the LqrCarver
initialization and BEFORE resizing takes place.

NOTE #2 : In all of the bias-related functions, the bias is
added on top of the existing one, so that all of the functions
can be called multiple times.

(See also the section "Additional notes" in the README file for
situations where the behaviour of biased regions can be
counter-intuitive.)

++ Using an array of floating-point values

The bias values are stored as an array of floating points.
It is possible to use directly one such array through
this function:

LqrRetVal lqr_carver_bias_add (LqrCarver *carver, gdouble *buffer, gint bias_factor)

  buffer      : the buffer containing the bias values
  bias_factor : the overall bias factor

The buffer is assumed to have the same size as the carver
image. The overall bias factor can be used to affect the global
bias level: if the elements of buffer are of order 1, a standard
choice for the bias_factor would be between 100 and 1000.

Note that this function, and all the following, will not swallow
the buffer (to the contrary of what happens e.g. when creating
a new carver).

++ Using another image

The bias can also be read from an rgb buffer. This buffer
has to be in the same format as the one used in the LqrCarver
constructor (but may have a different number of colour per
channel). The function is:

LqrRetVal lqr_carver_bias_add_rgb (LqrCarver *carver, guchar *buffer, gint bias_factor, gint bpp)

  buffer      : the buffer containing the RGB image to use as bias
  bias_factor : the overall bias factor
  bpp         : the number of colour channels of the buffer

As in the previous case, the buffer is assumed to hold and image
of the same size as the one in the carver.

The buffer contents will be transformed into floating-points by 
averaging the colour components and multiplying the result by the
alpha channel value.

NOTE : The existence of an alpha channel is inferred from the bpp
value: if this is 1 or 3, no alpha channel is assumed, if it is
2 or 4, it is assumed that the last channel is holds the alpha
value.

++ Operating on a specific area

The above functions operate on the whole LqrCarver image.
It is also possible to access specific regions by using these
functions:

LqrRetVal lqr_carver_bias_add_area (LqrCarver *carver, gdouble *buffer, gint bias_factor,
                                    gint width, gint height, gint x_off, gint y_off)

LqrRetVal lqr_carver_bias_add_rgb_area (LqrCarver *r, guchar *buffer, gint bias_factor, gint bpp,
                                        gint width, gint height, gint x_off, gint y_off)

  width  : the width of the area to access
  heigth : the height of the area to acess
  x_off  : the starting x value of the area to access
  y_off  : the starting y value of the area to access

The provided buffers have to be of size width * height, but the
specified areas need not to be strictly included inside the
LqrCarver image area : only the parts which overlap with it will be used.
For example, the offsets can also be negative.


+ Tuning
--------

++ Choosing a gradint function

The behaviour can be tuned through some additional functions.

The automatic feature detection relies on the computation
of the gradient in each pixel of the image. The function to use
can be set through:

void lqr_carver_set_gradient_function (LqrCarver * carver, LqrGradFuncType gf_ind)

The possible values for gf_ind are:
 
  LQR_GF_XABS   : transversal absolute value (default)
  LQR_GF_NORM   : gradient norm
  LQR_GF_SUMABS : sum of absulte values
  LQR_GF_NULL   : null

The null value can be used to override completely the automatic
feature detection (see the "Adding a bias" section above).

++ Choosing the resize order

When lqr_carver_resize is asked to resize along both directions
in a single step, it has to choose which direction to resize first.
The resize order can be changed through this function:

void lqr_carver_set_resize_order (LqrCarver *carver, LqrResizeOrder resize_order);

The possible values for resize_order are:
  LQR_RES_ORDER_HOR  : resize horizonally first (default) 
  LQR_RES_ORDER_VERT : resize vertically first



+ Dealing with the visibility maps (the seams)
----------------------------------------------

++ Activating the visibility map storage

By default, the computed visibility maps are wasted.
In order to be able to save them at the end of the
carving process, the following function has to be called:

void lqr_carver_set_dump_vmaps (LqrCarver *carver)

This will have the effect of dumping the visibility
map each time lqr_carver_resize is invoked. When
resizing along both directions, two maps will be 
dumped, one for each direction.

Alternatively, the current visibility map can be dumped
at any given moment by calling this function:

LqrRetVal lqr_vmap_dump (LqrCarver *carver)

The dumped maps are stored inside LqrVMap objects,
and these are attached to their corresponing
LqrCarver object through a linked list, whose
type is LqrVMapList.

++ Accessing the dumped visibility maps

To access the maps attached to a carver one has
first to obtain the pointer to the list, with the
function:

LqrVMapList * lqr_vmap_list_start(LqrCarver *carver)

Then, one can iterate through the attached maps by using
these two functions:

LqrVMap * lqr_vmap_list_current(LqrVMapList *list);
LqrVMapList * lqr_vmap_list_next (LqrVMapList * list);

Here is a sample code usage:

 >      LqrVMap *vmap;
 >      LqrVMapList *list;
 >      
 >      list = lqr_vmap_list_start (carver);
 >      while (list)
 >        {
 >          vmap = lqr_vmap_list_current (list);
 >          [ ... do something on vmap ... ]
 >          list = lqr_vmap_list_next (list);
 >        }

The maps will always be accessed in the order in which they were dumped.

Alternatively, one can apply a function to all the elements of
the list, through this function:

LqrRetVal lqr_vmap_list_foreach (LqrVMapList * list, LqrVMapFunc func, gpointer data)

Sample code:

 >      LqrVMapList *list;
 >      
 >      list = lqr_vmap_list_start (carver);
 >      lqr_vmap_list_foreach (list, my_func, NULL);

This needs that the function my_func is defined, as in this sample
code:

 >      LqrRetVal my_func (LqrVMap vmap, gpointer data)
 >        {
 >          [... do something on vmap ... ]
 >          return LQR_OK;
 >        }
    
In the above example, no data is actually passed on to the
function.

NOTE : in actual code the call to lqr_vmap_list_foreach should
be protected to test its return value, which is LQR_OK if all
my_func calls have been successful, or it will hold the first
non-successful return value from my_func.

++ The visibility map objects

The LqrVMap objects contain an int buffer with the actual map
data (plain array, ordered by row), plus all the information
needed to be able to recover it from scratch.

The information can be extracted with these functions:

gint * lqr_vmap_get_data (LqrVMap *vmap)
gint lqr_vmap_get_width (LqrVMap *vmap)
gint lqr_vmap_get_height (LqrVMap *vmap)
gint lqr_vmap_get_orientation (LqrVMap *vmap)
gint lqr_vmap_get_depth (LqrVMap *vmap)

The first one returns a pointer to the data buffer.

The orientation of the map is 0 if the map is to be used for
horizontal rescaling, 1 otherwise.

The depth of the map is the maximum amount of rescaling
possible with that map, either shrinking or enlarging.

For example, if we have a LqrVMap pointer called vmap,
we could access the value at (x,y) by:

 >      gint *buffer;
 >      gint width;
 >      gint vis;
 >
 >      buffer = lqr_vmap_get_data (vmap);
 >      width = lqr_vmap_get_width (vmap);
 >      vis =  buffer[y * width + x];

The value in `vis' will be either 0 (for uninitialized points,
which are always visible) or between 1 (least visible points,
the first to be carved away or to be duplicated) and (depth + 1)
(most visible points, the last to be carved away or to
be duplicated).

If the orientation is 0, the map allows resizing in the
whole range form (width - depth) to (width + depth).
If the orientation is 1, the analogue formula holds
with height in place of width.

++ Importing a visibility map in a carver

Having an LqrVMap object, one can load it in a LqrCarver
simply by calling this function:

LqrRetVal lqr_vmap_load (LqrCarver *carver, LqrVMap *vmap)

The carver must not to be initialized.

NOTE #1: This implies that the map cannot be updated, and
thet it will only be possible to resize the carver by an
amount vmap->depth and in the direction stored in
vmap->orientation. Invoking lqr_carver_resize with an
out-of-bounds argument returns a fatal error.

NOTE #2: Do not attach other carvers after you have loaded
a visibility map (see next section).

++ Saving and loading visibility maps to/from files

The library does not include methods to load/save
visibility maps to/from files. However, a way to do so
is included in the demo program `liquidrescale' in the
`examples' directory.



+ Attaching extra images
------------------------

++ Attaching a carver

Given an LqrCarver object, it is possible to attach an
arbitrary number of extra carvers to it: these will
passively undergo the same carving process as the root
carver. In order for this to be possible, the carvers
must be all of the same size.

The function to use is simply:

LqrRetVal lqr_carver_attach (LqrCarver * carver, LqrCarver * aux)

which attaches `aux' to `carver'.

It is not necessary that the parent LqrCarver is activated. In
fact, a carver can be attached to a carver which is itself
attached to another one.

Needless to say, no resizing operation should be done directly
on a LqrCarver once it has been attached to another LqrCarver.

NOTE : The carvers always have to be attached BEFORE loading
visibility maps.

++ Accessing attached carvers

Attached carvers can be read-out in the same way as their parents.
There are however also methods to span all them, in a way very similar
to that in which dumped LqrVMaps are accessed, but LqrVMapList
objects are substitued in this case by LqrCarverList objects.

First, the starting point of the list has to be retreived through:

LqrCarverList * lqr_carver_list_start(LqrCarver *r)

Then, one can iterate through the attached carvers by using
these two functions:

LqrCarver * lqr_carver_list_current(LqrCarverList *list);
LqrCarverList * lqr_carver_list_next (LqrCarverList * list);

Here is a sample code usage:

 >      LqrCarver *aux;
 >      LqrCarverList *list;
 >      
 >      list = lqr_carver_list_start (carver);
 >      while (list)
 >        {
 >          aux = lqr_carver_list_current (list);
 >          [ ... do something on aux ... ]
 >          list = lqr_carver_list_next (list);
 >        }

The carvers will always be accessed in the order in which they were dumped.

Alternatively, one can apply a function to all the elements of
the list, through this function:

LqrRetVal lqr_carver_list_foreach (LqrCarverList * list, LqrCarverFunc func, LqrDataTok data)

Sample code:

 >      LqrCarverList *list;
 >      LqrDataTok data_tok;
 >      
 >      list = lqr_carver_list_start (carver);
 >      data_tok->data = NULL;
 >      lqr_carver_list_foreach (list, my_func, data_tok);

This needs that the function my_func is defined, as in this sample
code:

 >      LqrRetVal my_func (LqrCarver *aux, LqrDataTok data)
 >        {
 >          [... do something on aux ... ]
 >          return LQR_OK;
 >        }
    
The data to be passed on to the LqrCarverFunc is of type
LqrDataTok. This is defined as a union, with the following
fields:
 
  LqrCarver *carver
  gint integer;
  gpointer data;

In the above example, no data is actually passed on to the
function.

NOTE : in actual code the call to lqr_carver_list_foreach should
be protected to test its return value, which is LQR_OK if all
my_func calls have been successful, or it will hold the first
non-successful return value from my_func.



+ Progress indicators
---------------------

By default, the resizing performed silently. However,
it is possible to define progress report functions, to receive
feedback while the resizing is in progress.

This is done through the LqrProgress objects. One such object
is created through the function:

LqrProgress * lqr_progress_new(void)

and can be associated to a LqrCarver object through this function:

void lqr_carver_set_progress (LqrCarver *r, LqrProgress *p)

Before attaching a progress, it needs to be set up.
First, hook functions have to be set, which specify the action
to take as the process starts, progresses, and ends, by using
the functions:

LqrRetVal lqr_progress_set_init(LqrProgress * p, LqrProgressFuncInit init_func);
LqrRetVal lqr_progress_set_update(LqrProgress * p, LqrProgressFuncUpdate update_func);
LqrRetVal lqr_progress_set_end(LqrProgress * p, LqrProgressFuncEnd end_func);

as in this sample piece of code:

 >      LqrProgress *p;
 > 
 >      p = lqr_progress_new();
 >      lqr_progress_set_init (p, my_init);
 >      lqr_progress_set_update (p, my_update);
 >      lqr_progress_set_end (p, my_end);

This requires that the hook functions my_init, my_update and my_end
are defined as in the following sample declarations:

 >      LqrRetVal my_init (const gchar *init_message);
 >      LqrRetVal my_update (gdouble percentage);
 >      LqrRetVal my_end (const gchar *end_message);

The init and end messages that will be passed to the hooks will change,
depending if the resizing is occurring in the horizontal or in the
vertical direction. The defaults are:
              
                  init              end
           _______________________________
          |                      |        |
  widht   | "Resizing width..."  | "done" |
          |______________________|________|
          |                      |        |
  height  | "Resizing height..." | "done" |
          |______________________|________|

These can be changed with these functions:

LqrRetVal lqr_progress_set_init_width_message(LqrProgress *p, const gchar * message)
LqrRetVal lqr_progress_set_init_height_message(LqrProgress *p, const gchar * message)
LqrRetVal lqr_progress_set_end_width_message(LqrProgress *p, const gchar * message)
LqrRetVal lqr_progress_set_end_height_message(LqrProgress *p, const gchar * message)

The update hook will receive as an argument the completion percentage.
The update step can be specified through:

LqrRetVal lqr_progress_set_update_step(LqrProgress *p, gfloat update_step)

The default step is 0.02 (i.e. 2%).



+ Full list of library methods
------------------------------

++ Carver objects

  +++ constructor and destructor
    LqrCarver * lqr_carver_new (guchar *buffer, gint width, gint height, gint bpp)
    void lqr_carver_destroy (LqrCarver *r)

  +++ initialization
    LqrRetVal lqr_carver_init (LqrCarver *r, gint delta_x, gfloat rigidity)

  +++ image manipulations
    LqrRetVal lqr_carver_resize (LqrCarver *r, gint w1, gint h1)
    LqrRetVal lqr_carver_flatten (LqrCarver *r)

  +++ readout
    void lqr_carver_scan_reset (LqrCarver *r)
    gboolean lqr_carver_scan (LqrCarver *r, gint *x, gint *y, guchar **rgb)
    gboolean lqr_carver_scan_by_row (LqrCarver *r)
    gboolean lqr_carver_scan_line (LqrCarver *r, gint *n, guchar **rgb)

  +++ get values
    gint lqr_carver_get_width (LqrCarver *r)
    gint lqr_carver_get_height (LqrCarver *r)
    gint lqr_carver_get_bpp (LqrCarver *r)

  +++ setting options
    void lqr_carver_set_gradient_function (LqrCarver * r, LqrGradFuncType gf_ind);
    void lqr_carver_set_resize_order (LqrCarver *r, LqrResizeOrder resize_order);
    void lqr_carver_set_dump_vmaps (LqrCarver *r);

  +++ setting progress reports
    void lqr_carver_set_progress (LqrCarver *r, LqrProgress *p)

  +++ attaching auxiliary carvers
    LqrRetVal lqr_carver_attach (LqrCarver * r, LqrCarver * aux)


++ Visibility maps
  
  +++ constructor and destructor
    LqrVMap* lqr_vmap_new (gint *buffer, gint width, gint heigth,
                           gint depth, gint orientation)
    void lqr_vmap_destroy (LqrVMap *vmap)

  +++ get values
    gint * lqr_vmap_get_data(LqrVMap *vmap)
    gint lqr_vmap_get_width(LqrVMap *vmap)
    gint lqr_vmap_get_height(LqrVMap *vmap)
    gint lqr_vmap_get_depth(LqrVMap *vmap)
    gint lqr_vmap_get_orientation(LqrVMap *vmap)

  +++ dump and load
    LqrRetVal lqr_vmap_dump (LqrCarver *r)
    LqrRetVal lqr_vmap_load (LqrCarver *r, LqrVMap *vmap)
  
  +++ visibility map lists
    LqrVMapList * lqr_vmap_list_start(LqrCarver *r)
    LqrVMap * lqr_vmap_list_current(LqrVMapList *list)
    LqrVMapList * lqr_vmap_list_next (LqrVMapList * list)
    LqrRetVal lqr_vmap_list_foreach (LqrVMapList * list, LqrVMapFunc func, gpointer data)


++ Adding a bias

  +++ Floating point input
    LqrRetVal lqr_carver_bias_add(LqrCarver *r, gdouble *buffer, gint bias_factor)
    LqrRetVal lqr_carver_bias_add_area(LqrCarver *r, gdouble *buffer, gint bias_factor,
                                       gint width, gint height, gint x_off, gint y_off)

  +++ RGB input
    LqrRetVal lqr_carver_bias_add_rgb(LqrCarver *r, guchar *buffer, gint bias_factor, gint bpp)
    LqrRetVal lqr_carver_bias_add_rgb_area(LqrCarver *r, guchar *buffer, gint bias_factor, gint bpp,
                                           gint width, gint height, gint x_off, gint y_off)


++ Attached auxiliary carvers

  +++ Iterating over the atteched carvers
    LqrCarverList * lqr_carver_list_start(LqrCarver *r);
    LqrCarver * lqr_carver_list_current(LqrCarverList *list);
    LqrCarverList * lqr_carver_list_next (LqrCarverList * list);
    LqrRetVal lqr_carver_list_foreach (LqrCarverList * list, LqrCarverFunc func, LqrDataTok data);


++ Setting a progress report

  +++ constructor
    LqrProgress * lqr_progress_new(void)

  +++ setting hooks
    LqrRetVal lqr_progress_set_init(LqrProgress * p, LqrProgressFuncInit init_func)
    LqrRetVal lqr_progress_set_update(LqrProgress * p, LqrProgressFuncInit update_func)
    LqrRetVal lqr_progress_set_end(LqrProgress * p, LqrProgressFuncInit end_func)

  +++ setting parameters
    LqrRetVal lqr_progress_set_update_step(LqrProgress *p, gfloat update_step)
    LqrRetVal lqr_progress_set_init_width_message(LqrProgress *p, const gchar * message)
    LqrRetVal lqr_progress_set_init_height_message(LqrProgress *p, const gchar * message)
    LqrRetVal lqr_progress_set_end_width_message(LqrProgress *p, const gchar * message)
    LqrRetVal lqr_progress_set_end_height_message(LqrProgress *p, const gchar * message)



+ Copyright
-----------

Copyright (C) 2007 Carlo Baldassi <carlobaldassi@yahoo.it>

